import copy
import os
from typing import List
import pprint 

from langchain_core.messages import AIMessage, HumanMessage, SystemMessage

from dotenv import load_dotenv

from utils.schemas import Reviewer, Queries, QAPair, Paper
from utils.chat import invoke_llm_langchain
from utils.retriever import FileRetriever
from agentstates import QuestionState, AnswerState, IntermediateAnswerState

## Idea:
### 1. We assume that the LLM would not be able to directly answer a reasoning based Yes/No question. Hence the question would be broken into sub-queries.
### 2. The sub-queries would be generated by the LLM. These sub-queries would be used as search queries for retrieval (make use of LLM to form 2 versions of each sub-query).
### 3. Form an intermediate answer for each of the sub-queries. 
### 4. Provide these Q&A pairs to the LLM as reference to form the final answer.

## The transition from QuestionState to AnswerState would be done by an intermediate `compile_questions` node.
## This is because we would not require information about individual reviewers after generation of questions.

load_dotenv()

api_key = os.getenv("GROQ_API_KEY")

def generate_sub_queries(state:AnswerState) -> IntermediateAnswerState:
    """
    Generate sub-queries for each question in the state
    """
    messages = state.messages
    paper = state.paper
    questions = state.questions
    conference = state.conference
    conference_description = state.conference_description

    updated_state = IntermediateAnswerState(messages=messages, 
                                            paper=paper, 
                                            conference=conference,
                                            conference_description=conference_description,)

    def generate_sub_queries_by_question(messages, question:str) -> List[QAPair]:
        """
        Generate sub-queries for a given question
        """
        sub_queries = []
        sub_query_gen_prompt = f"""
        You are provided with a boolean Yes/No question. You need to generate sub-queries based on the given question.
        These sub-queries will be uses to answer the larger question in a more detailed manner.
        Following is the question you need to generate sub-queries for:

        <Question>
        {question}
        </Question>

        Generate your answer in the form of a PYTHON list of strings, enclosed within `[]`.
        Each question number should be unique and in order. All questions must be a Python string, enclosed in `""` (double quotes).
        Do not make any syntax error.
        """

        messages.append(HumanMessage(content=sub_query_gen_prompt))
        messages, input_tokens, output_tokens = invoke_llm_langchain(messages, api_key=api_key)
        sub_queries = messages[-1].content
        sub_queries = eval(sub_queries.replace("\n", "").replace("```json", "").replace("```python", "").replace("```", ""))
        print(question)
        pprint.pprint(sub_queries)
        print()
        sub_qas = []
        for ques in sub_queries:
            sub_qa = QAPair(query=ques)
            sub_qas.append(sub_qa)

        return sub_qas

    questions_updated = []
    for question in questions:
        sub_query_gen_system_message = f"""
        You shall be provided with multiple boolean Yes/No questions. You will be required to generate sub-queries based on the given questions.
        The sub-queries must be unique and must be able to fetch enough information to answer the given question.
        The sub-queries should contain all questions which are relevant to the reasoning pathway to answer the given question, that is, based on the given sub-queries and their answers, one should be able to form the complete reasoning pathway to formulate the answer to the main query.
        Follow any instruction given henceforth strictly while generating the sub-queries.
        """
        sub_query_gen_messages = [SystemMessage(content=sub_query_gen_system_message)]
        sub_queries = generate_sub_queries_by_question(sub_query_gen_messages, question)
        question_updated = Queries(original_query=question, sub_qas=sub_queries)
        questions_updated.append(question_updated)

    updated_state.questions = questions_updated
    return updated_state

def retrieve_references(state:IntermediateAnswerState) -> IntermediateAnswerState:
    """
    Retrieve references for each sub-query in the state
    """
    messages = state.messages
    paper = state.paper
    questions = state.questions
    conference = state.conference

    def compile_references(references) -> str:
        """
        Compile the references into a single string
        """
        compiled_references = ""
        for i, reference in enumerate(references):
            reference_ = f"""
            <Document {i+1}>
            {reference.text}
            </Document {i+1}>
            """
            compiled_references += f"\n{reference_}\n"
        return compiled_references

    updated_state = copy.deepcopy(state)

    retriever = FileRetriever(
        object_id=paper.object_id,
        credentials_file="credentials.json",
        embedder_model="intfloat/e5-large-v2"
    )

    for question in questions:
        # question is a Queries object 
        for sub_qa in question.sub_qas:
            # sub_qa is a QAPair object
            references = retriever.retrieve_data(query=sub_qa.query, k=3, timeout=20)
            sub_qa.references = compile_references(references) ## Update this in <Document> format

    updated_state.questions = questions
    return updated_state

def answer_sub_queries(state:IntermediateAnswerState) -> IntermediateAnswerState:
    """
    Answer sub-queries for each question in the state
    """
    messages = state.messages
    paper = state.paper
    questions = state.questions
    conference = state.conference

    updated_state = copy.deepcopy(state)

    answer_prompt_template = """
    You are given a question and a list of references. Answer the question based on the references.
    The given question is a sub-query used to answer a larger, more complex question.


    You have been provided with the following references:
    <References>
    \t{references}
    </References>

    Following is the query needed to be answered:
    <Query>
    {query}
    </Query>

    You are also provided with the larger question that this sub-query is a part of for your reference:
    `{original_query}`

    Based on the references provided, answer the query within the <Query></Query> tag. 
    Keep the answer to the point. DO NOT refer to any inforation outside the references provided.
    """

    answer_system_message = """
    Following you shall be provided with a list of references and a query. Answer the query based on the references provided.

    Remember that each query is a sub-query used to answer a larger, more complex question, and both will be provided to you for reference.

    You are expected to answer ONLY the smaller query, only using the larger question as a reference. Do not hallucinate.

    Return your response in plain text format. Do not include any additional information. Keep your answers logical and concise.
    """

    for question in questions:
        # question is a Queries object 
        original_query = question.original_query
        for sub_qa in question.sub_qas:
            # sub_qa is a QAPair object
            answering_messages = [SystemMessage(content=answer_system_message)]
            references = sub_qa.references
            query = sub_qa.query
            answering_message = answer_prompt_template.format(references=references, query=query, original_query=original_query)
            answering_messages.append(HumanMessage(content=answering_message))
            answering_messages, input_tokens, output_tokens = invoke_llm_langchain(answering_messages, api_key=api_key)
            sub_qa.answer = answering_messages[-1].content

    updated_state.questions = questions
    return updated_state

def summarise_results(state:IntermediateAnswerState) -> AnswerState:
    """
    Summarise the results of the sub-queries into a final Yes/No answer
    """
    messages = state.messages
    paper = state.paper
    questions = state.questions
    conference = state.conference
    conference_description = state.conference_description

    updated_state = AnswerState(messages=messages,
                                paper=paper,
                                conference=conference,
                                conference_description=conference_description,
                                reviewers=state.reviewers)

    ## Summarise the results of the sub-queries into a final Yes/No answer
    ## For each question, compile the QAPair objects into a single string
    ## Use this string to form the final answer

    summary_template = """
    Following are the sub-queries of the given question and their answer. 
    You need to refer to these sub-queries and their answers, compile their info and generate the final `YES`/`NO` answer.

    <SubQueries>
    {compiled_qas}
    </SubQueries>

    The question to be answered is:
    `{question}`

    Logically decide and generate your final answer only as `YES` or `NO` without any extra verbiage. 
    DO NOT return anything else except `YES` or `NO`.
    """

    summary_system_message = f"""
    Following you shall be provided with a list of sub-queries and their answers. Each sub-query is a part of the given larger question.
    The question is used to determine publishability of the paper in the conference `{conference}`. Following is a brief description of the conference:

    <ConferenceDescription>
    {conference_description}
    </ConferenceDescription>

    Generate your final answer based on the following instructions
    1. The answer should strictly be `YES` or `NO`. Logically decide the correct answer.
    2. You are expected to logically decide based on the sub-queries and their answers and return only `YES` or `NO`.
    3. Return you answer in 'plain-text' format. Do not include any additional information or verbiage. 
    4. Do not include any Markdown formatting or HTML tags in your answer.
    """

    def merge_qa_pair(qa_pair:QAPair) -> str:
        """
        Merge the query and answer into a single string
        """
        return f"\nQ: {qa_pair.query} \nA:{qa_pair.answer}\n"
    
    questions_updated, answers = [], []
    for question in questions:
        # question is a Queries object 
        compiled_qas = ""
        questions_updated.append(question.original_query)
        for sub_qa in question.sub_qas:
            # sub_qa is a QAPair object
            compiled_qas += merge_qa_pair(sub_qa)
        summarising_messages = [SystemMessage(content=summary_system_message)]
        summarising_message = summary_template.format(compiled_qas=compiled_qas, question=question.original_query)
        summarising_messages.append(HumanMessage(content=summarising_message))

        summarising_messages, input_tokens, output_tokens = invoke_llm_langchain(summarising_messages, api_key=api_key)
        final_answer = summarising_messages[-1].content
        if "yes" in final_answer.lower():
            final_answer = "YES"
        else:
            final_answer = "NO"
        answers.append(final_answer)

    updated_state.answers = answers
    updated_state.questions = questions_updated
    count_yes = sum(1 for ans in answers if ans == "YES")
    count_no = len(answers) - count_yes

    if count_yes >= count_no:
        updated_state.publishable = True
    else:
        updated_state.publishable = False

    return updated_state

if __name__ == "__main__":

    state = AnswerState(
        messages=[],
        paper=Paper(object_id="11m_cx50ZGVUP_oAiR7_qzXC_7jStGluX0", title="Sample Paper", filename="sample_paper.pdf"),
        topic="Sample Topic",
        questions=["Is the paper well-written?", "Is the paper well-researched?", "Is the paper well-structured?"],
        conference="Sample Conference",
        conference_description="This is a sample conference description",
        reviewers=[
            Reviewer(id=1, specialisation="Sample Specialisation 1", questions=["Is the paper well-written?"]),
            Reviewer(id=2, specialisation="Sample Specialisation 2", questions=["Is the paper well-researched?"]),
            Reviewer(id=3, specialisation="Sample Specialisation 3", questions=["Is the paper well-structured?"])
        ]
    )

    print("Generating sub-queries...")
    intermediate_state = generate_sub_queries(state)
    print("Retrieving references...")
    intermediate_state = retrieve_references(intermediate_state)
    print("Answering sub-queries...")
    intermediate_state = answer_sub_queries(intermediate_state)
    print("Summarising results...")
    final_state = summarise_results(intermediate_state)

    print("Final State:")

