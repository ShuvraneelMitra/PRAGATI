import copy
from typing import List

from langchain_core.messages import AIMessage, HumanMessage, SystemMessage

from utils.schemas import Reviewer, Queries, QAPair, Paper
from utils.chat import invoke_llm_langchain
from utils.retriever import FileRetriever
from agentstates import QuestionState, AnswerState, IntermediateAnswerState

## Idea:
### 1. We assume that the LLM would not be able to directly answer a reasoning based Yes/No question. Hence the question would be broken into sub-queries.
### 2. The sub-queries would be generated by the LLM. These sub-queries would be used as search queries for retrieval (make use of LLM to form 2 versions of each sub-query).
### 3. Form an intermediate answer for each of the sub-queries. 
### 4. Provide these Q&A pairs to the LLM as reference to form the final answer.

## The transition from QuestionState to AnswerState would be done by an intermediate `compile_questions` node.
## This is because we would not require information about individual reviewers after generation of questions.

def generate_sub_queries(state:AnswerState) -> IntermediateAnswerState:
    """
    Generate sub-queries for each question in the state
    """
    messages = state['messages']
    paper = state['paper']
    topic = state['topic']
    questions = state['questions']
    conference = state['conference']

    updated_state = copy.deepcopy(state)

    def generate_sub_queries_by_question(question:str) -> List[QAPair]:
        """
        Generate sub-queries for a given question
        """
        sub_queries = []
        return sub_queries

    questions_updated = []
    for question in questions:
        sub_queries = generate_sub_queries_by_question(question)
        question_updated = Queries(original_query=question, sub_queries=sub_queries)
        questions_updated.append(question_updated)

    updated_state['questions'] = questions_updated
    return updated_state

def retrieve_references(state:IntermediateAnswerState) -> IntermediateAnswerState:
    """
    Retrieve references for each sub-query in the state
    """
    messages = state['messages']
    paper = state['paper']
    topic = state['topic']
    questions = state['questions']
    conference = state['conference']

    def compile_references(references) -> str:
        """
        Compile the references into a single string
        """
        compiled_references = ""
        for i, reference in enumerate(references):
            reference_ = f"""
            <Document {i+1}>
            {reference['text']}
            </Document {i+1}>
            """
            compiled_references += f"\n{reference_}\n"
        return compiled_references

    updated_state = copy.deepcopy(state)

    retriever = FileRetriever(
        object_id=paper['object_id'],
        credentials_file="credentials.json",
        embedder_model="intfloat/e5-large-v2"
    )

    for question in questions:
        # question is a Queries object 
        for sub_qa in question['sub_qas']:
            # sub_qa is a QAPair object
            references = retriever.retrieve_data(query=sub_qa, k=3, timeout=20)
            sub_qa['references'] = references ## Update this in <Document> format

    updated_state['questions'] = questions
    return updated_state

def answer_sub_queries(state:IntermediateAnswerState) -> IntermediateAnswerState:
    """
    Answer sub-queries for each question in the state
    """
    messages = state['messages']
    paper = state['paper']
    topic = state['topic']
    questions = state['questions']
    conference = state['conference']

    updated_state = copy.deepcopy(state)

    answer_prompt_template = """
    You are given a question and a list of references. Answer the question based on the references.
    The given question is a sub-query used to answer a larger, more complex question.


    You have been provided with the following references:
    <References>
    \t{references}
    </References>

    Following is the query needed to be answered:
    <Query>
    `{query}`
    </Query>

    You are also provided with the larger question that this sub-query is a part of for your reference:
    `{original_query}`

    Based on the references provided, answer the query within the <Query></Query> tag. 
    Keep the answer to the point. DO NOT refer to any inforation outside the references provided.
    """

    answer_system_message = """
    Following you shall be provided with a list of references and a query. Answer the query based on the references provided.

    Remember that each query is a sub-query used to answer a larger, more complex question, and both will be provided to you for reference.

    You are expected to answer ONLY the smaller query, only using the larger question as a reference. Do not hallucinate.

    Return your response in plain text format. Do not include any additional information. Keep your answers logical and concise.
    """

    for question in questions:
        # question is a Queries object 
        original_query = question['original_query']
        for sub_qa in question['sub_qas']:
            # sub_qa is a QAPair object
            answering_messages = [SystemMessage(content=answer_system_message)]
            references = sub_qa['references']
            query = sub_qa['query']
            answering_message = answer_prompt_template.format(references=references, query=query, original_query=original_query)
            answering_messages.append(HumanMessage(content=answering_message))
            answering_messages, input_tokens, output_tokens = invoke_llm_langchain(answering_messages)
            sub_qa['answer'] = answering_messages[-1].content

    updated_state['questions'] = questions
    return updated_state

def summarise_results(state:IntermediateAnswerState) -> AnswerState:
    """
    Summarise the results of the sub-queries into a final Yes/No answer
    """
    messages = state['messages']
    paper = state['paper']
    topic = state['topic']
    questions = state['questions']
    conference = state['conference']
    conference_description = state['conference_description']

    updated_state = copy.deepcopy(state)

    ## Summarise the results of the sub-queries into a final Yes/No answer
    ## For each question, compile the QAPair objects into a single string
    ## Use this string to form the final answer

    summary_template = """
    Following are the sub-queries of the given question and their answer. 
    You need to refer to these sub-queries and their answers, compile their info and generate the final `YES`/`NO` answer.

    <SubQueries>
    {compiled_qas}
    </SubQueries>

    The question to be answered is:
    `{question}`

    Logically decide and generate your final answer only as `YES` or `NO` without any extra verbiage. 
    DO NOT return anything else except `YES` or `NO`.
    """

    summary_system_message = f"""
    Following you shall be provided with a list of sub-queries and their answers. Each sub-query is a part of the given larger question.
    The question is used to determine publishability of the paper in the conference `{conference}`. Following is a brief description of the conference:

    <ConferenceDescription>
    {conference_description}
    </ConferenceDescription>

    Generate your final answer based on the following instructions
    1. The answer should strictly be `YES` or `NO`. Logically decide the correct answer.
    2. You are expected to logically decide based on the sub-queries and their answers and return only `YES` or `NO`.
    3. Return you answer in 'plain-text' format. Do not include any additional information or verbiage. 
    4. Do not include any Markdown formatting or HTML tags in your answer.
    """

    def merge_qa_pair(qa_pair:QAPair) -> str:
        """
        Merge the query and answer into a single string
        """
        return f"\nQ: {qa_pair['query']} \nA:{qa_pair['answer']}\n"
    
    questions_updated, answers = [], []
    for question in questions:
        # question is a Queries object 
        compiled_qas = ""
        questions_updated.append(question['original_query'])
        for sub_qa in question['sub_qas']:
            # sub_qa is a QAPair object
            compiled_qas += merge_qa_pair(sub_qa)
        summarising_messages = [SystemMessage(content=summary_system_message)]
        summarising_message = summary_template.format(compiled_qas=compiled_qas, question=question['original_query'])
        summarising_messages.append(HumanMessage(content=summarising_message))

        summarising_messages, input_tokens, output_tokens = invoke_llm_langchain(summarising_messages)
        final_answer = summarising_messages[-1].content
        if "yes" in final_answer.lower():
            final_answer = "YES"
        else:
            final_answer = "NO"
        answers.append(final_answer)

    updated_state['answers'] = answers
    updated_state['questions'] = questions_updated
    count_yes = sum(1 for ans in answers if ans == "YES")
    count_no = len(answers) - count_yes

    if count_yes >= count_no:
        updated_state['publishable'] = True
    else:
        updated_state['publishable'] = False

    return updated_state

if __name__ == "__main__":

    ## Test the functions

    state = QuestionState(
        messages=[],
        paper=Paper(object_id="11m_cx50ZGVUP_oAiR7_qzXC_7jStGluX0", title="Sample Paper", filename="sample_paper.pdf"),
        topic="Sample Topic",
        questions=["Is the paper well-written?", "Is the paper well-researched?", "Is the paper well-structured?"],
        conference="Sample Conference",
        conference_description="This is a sample conference description",
        reviewers=[
            Reviewer(id=1, specialisation="Sample Specialisation 1", questions=["Is the paper well-written?"]),
            Reviewer(id=2, specialisation="Sample Specialisation 2", questions=["Is the paper well-researched?"]),
            Reviewer(id=3, specialisation="Sample Specialisation 3", questions=["Is the paper well-structured?"])
        ]
    )

    print("Generating sub-queries...")
    intermediate_state = generate_sub_queries(state)
    print("Retrieving references...")
    intermediate_state = retrieve_references(intermediate_state)
    print("Answering sub-queries...")
    intermediate_state = answer_sub_queries(intermediate_state)
    print("Summarising results...")
    final_state = summarise_results(intermediate_state)

    print("Final State:")

